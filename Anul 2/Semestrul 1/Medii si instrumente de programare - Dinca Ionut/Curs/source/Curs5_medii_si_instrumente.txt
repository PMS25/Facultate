Implementare interfetelor in C#

Ce este o interfata C#?

Este un tip care contine un set de declarari de metode (implicit publice),
fara implementare.

O interfata evidentiaza metodele comune mai multor clase, publice, care 
ar trebui sa fie utilizate de clasele client.

Spunem o clasa adera la o interfata daca o implementeaza (implementeaza toate
metodele acesteia).

public interface IMyMethods 
{
	void MyMethod(); //metoda fara implementare - nu se specifica public
}

class MyConcreteMethods : IMyMethods
{
	//aici, obligatoriu, clasa trebuie sa implementeze toate metodele interfetei
	public void MyMethod()
	{
	
	}	
}

Care este marele avantaj al utilizarii interfetelor?

Putem scrie aplicatii cu un caracter general, usor de extins!
De ce?

Sa presupunem ca o clasa are nevoie sa utilizeze metode ale clasei 'MyConcreteMethods' (a caror implementare s-ar putea
modifica in viitor, dar semnatura metodelor se pastreaza).

class Client
{
	
	MyConcreteMethods Methods {get;set;}

	public void Task()
	{
		Methods.MyMethod();
	}

}

Codul de mai sus spunem ca depinde de clasa concreta 'MyConcreteMethods', prin urmare, daca dorim sa modificam
codul metodei 'MyMethod', trebuie sa recompilam intreaga clasa.

Modul corect de a declara proprietatea (referinta) 'Methods' este prin intermediul interfetei 'IMyMethods', deoarece
aceasta va putea fi substituita ulterior cu orice clasa care o implementeaza.

class Client
{
	
	IMyMethods Methods { get;set; }

	public Client(IMyMethods methods)
	{
		Methods = methods;
	}

	public void Task()
	{
		Methods.MyMethod();
	}

}


Client c = new Client(new MyConcreteMethods());
c.Task();

Clasa Client fiind absolut independenta de clasele concrete care implementeaza interfata, spunem ca este extensibila
din punct de vedere al metodei 'MyMethod' utilizata in metoda Task! Deoarece putem oricand implementa o versiune diferita
intr-o clasa (noua) care implementeaza interfata!! (Fara sa fie necesar sa modificam codul clasei!!!)

class MyConcreteMethodsNewVersion : IMyMethods
{
	//noua versiune
	
}

Client c = new Client(new MyConcreteMethodsNewVersion ());
c.Task(); //se va utiliza acum noua versiune!!

Observatie: 

Interfetele pot fi declarate in combinatie cu tipuri generice!

public intreface IMyGenericInterface<T>
{
	T GetObject();
	void ChangeOBject(T value);
}

class MyConcreteClass : IMyGenericInterface<Student>
{
	Student GetObject()
	{

	}

	void ChangeOBject(Student value)
	{
	
	}
}

Studiu de caz (aplicatie la interfete):

Sa se implementeze o aplicatie pentru administrea de proprietati (Estate) ale unui
proprietar (Owner). 

Tipuri de proprietati:

Apartament,
Casa,
Teren,
Birouri

Aplicatia va permite urmatoarele:

adaugare/modificare/stergere/vizualizare date despre proprietari (Owner)
adaugare/modificare/stergere/vizualizare proprietati (Estates)

In plus, se vor implementa: cautare si ordonare proprietati dupa diverse criterii (pret, nume,...)

O proprietate contine urmatoarele elemente:
    

public class Estate
    {
        public int Id { get; set; } //cheia primara in tabelul Estate
        public string Name { get; set; }
        public string Address { get; set; }
        public int OwnerId { get; set; }
        public double Price { get; set; }
        public int Type { get; set; }
        public DateTime CreateDate { get; set; }
        public List<Picture> Pictures { get; set; }

        public Estate()
        {
            Pictures = new List<Picture>();
        }
    }

  public class Picture
    {
        public int Id { get; set; } //cheia primara in tabel
        public string Name { get; set; }
        public DateTime CreateDate { get; set; }
        public long Size { get; set; }
    }

   public class Owner
    {
        public int Id { get; set; } //cheia primara din tabel
        public string Name { get; set; }
        public string Email { get; set; }
        public string Phone { get; set; }
        public string Cnp { get; set; }
        public List<Estate> Estates { get; set; }

        public Owner()
        {
            Estates = new List<Estate>();
        }
    }




Aplicatia va salva date intr-o baza de date (Sql Server) - 

Tabele: Owner, Estate, Picture - OwnerEstate, EstatePicture

Pictures vor fi salvate pe disk, in folderul "Pictures" (la o cale stabilita in "App.config"!!)
Tot in "App.config" se va memora si connection string catre baza de date!!

Cum implementam accesul la baza de date din aplicatie, astfel incat sa utilizam eficient interfetele,
eventual sa putem extinde usor aplicatia!

namespace EstateManagement.Repository
{
    public interface IRepository<T>
    {
        T GetById(int id);
        List<T> GetAll();
        T Create(T value); //creaza un nou obiect T in baza de date
        void Delete(int id);
        T Update(T value); //se face update (modificare) a obiectului T
    }
}

namespace EstateManagement.Repository.SqlRepository
{
    internal class EstateRepository : IRepository<Estate>
    {
        //cod de conectare la baza de date, executarea instructiunilor respective (SELECT, UPDATE, INSERT, DELETE)

        public Estate Create(Estate value)
        {
            throw new NotImplementedException();
        }

        public void Delete(int id)
        {
            throw new NotImplementedException();
        }

        public List<Estate> GetAll()
        {
            throw new NotImplementedException();
        }

        public Estate GetById(int id)
        {
            //SELECT * FROM Estate WHERE EstateId = {id}....
            throw new NotImplementedException(); 
        }

        public Estate Update(Estate value)
        {
            throw new NotImplementedException();
        }
    }
}

/////////////////////////////////////////////////////////////////////////////////
namespace EstateManagement.Repository.SqlRepository
{
    internal class OwnerRepository : IRepository<Owner>
    {
        public Owner Create(Owner value)
        {
            throw new NotImplementedException();
        }

        public void Delete(int id)
        {
            throw new NotImplementedException();
        }

        public List<Owner> GetAll()
        {
            throw new NotImplementedException();
        }

        public Owner GetById(int id)
        {
            throw new NotImplementedException();
        }

        public Owner Update(Owner value)
        {
            throw new NotImplementedException();
        }
    }
}

//////////////////////////////////////////////////////////////////////
namespace EstateManagement.Repository.SqlRepository
{
    internal class PictureRepository : IRepository<Picture>
    {
        public Picture Create(Picture value)
        {
            throw new NotImplementedException();
        }

        public void Delete(int id)
        {
            throw new NotImplementedException();
        }

        public List<Picture> GetAll()
        {
            throw new NotImplementedException();
        }

        public Picture GetById(int id)
        {
            throw new NotImplementedException();
        }

        public Picture Update(Picture value)
        {
            throw new NotImplementedException();
        }
    }
}

//////////////////////////////////////////////////////////////////////
namespace EstateManagement.Repository
{
    public class RepositoryFactory
    {
        public static IRepository<Estate> CreateEstateRepository()
        {
            //obtine repository type (1 sau 2) din app.config
            var repType = 1;

            switch (repType) 
            {
                case (int)RepositoryType.Sql: return new EstateManagement.Repository.SqlRepository.EstateRepository();
                case (int)RepositoryType.Json: return new EstateManagement.Repository.JsonRepository.EstateRepository();
            }
               
            //default
            return new EstateManagement.Repository.SqlRepository.EstateRepository();
        }

        public static IRepository<Picture> CreatePictureRepository()
        {
            return new EstateManagement.Repository.SqlRepository.PictureRepository();
        }

        public static IRepository<Owner> CreateOwnerRepository()
        {
            return new EstateManagement.Repository.SqlRepository.OwnerRepository();
        }
    }
}


Tabele in baza de date

Estate

EstateId int - cheie primara (autogenerata)
OwnerId int  - cheie straina (catre Owner)
//in rest toate campurile din modelul Estate, cu tipurile aferente!!

Owner

OwnerId int - cheie primara (autogenerata)
... toate campurile din modelul (clasa) Owner

Picture

PictureId int - cheie primara
EstateIdint - cheie straina
....

Deadline (2 weeks): prima saptamana din decembrie!






























