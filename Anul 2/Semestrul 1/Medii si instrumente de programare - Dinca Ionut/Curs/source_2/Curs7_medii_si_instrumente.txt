- Tipul delegate in C#
- Metode anonime
- Expresii lambda
- Metode extinse (extension methods)

1) Tipul delegate

Tipul delegate permite incapsularea metodelor (Ca referinta) in obiecte.

Este similar pointerilor la functii din C++, dar de data aceasta
varianta object oriented, prin intermediul unei referinte.

Daca scriem o aplicatie in care se doreste executarea unor anumite actiuni,
pentru care cunoastem "semnatura" acestora (tip returnat, lista parametrii), 
dar nu ne intereseaza neaparat implementarea lor (aceasta va putea fi stabilita
ulterior), putem utiliza tipul "delegate"

In acest fel aplicatia capata un caracter general, in sensul ca actiunea poate
fi oricand modificata/optimizata/schimbata!

Sintaxa:

public delegate tip_returnat nume_delegate ([lista_param]);

Exemplu:

public delegate int Operation(int a, int b); 

acest delegate poate incapsula orice functie (metoda) care returneaza double,
si are doi parametrii de tip int.

Cum se ataseaza o metoda la un delegat (instantierea delegatului)

namespace DelegateApp
{
    class Methods
    {
        public static int Add(int a, int b)
        {
            return a + b;
        }

        public static int Mult(int a, int b)
        {
            return a * b;
        }
    }

    public delegate int Operation(int a, int b);
    public delegate int Operation1();
    
    class InstanceMethods
    {
        public int A { get; set; }
        public int B { get; set; }
       
        public int Add()
        {
            return A + B;
        }

        public int Mult()
        {
            return A * B;
        }
    }
    
    class Program
    {
        static void Main(string[] args)
        {
            Operation op; //op este un obiect de tip delegat!!
            op = new Operation(Methods.Mult);

            //apelarea delegatului se face ca si cum am apela metoda incapsulata!
            Console.WriteLine(op(3, 4));
            InstanceMethods obj = new InstanceMethods()
            {
                A = 10,
                B = 20
            };

            Operation1 op1 = new Operation1(obj.Add);

            Console.WriteLine(op1());

            Console.ReadKey();
        }
    }
}


Observatie: un delegate poate incapsula de fapt mai multe metode (multicast)

(cu + sau +=)

static void Main(string[] args)
        {
            Operation op; //op este un obiect de tip delegat!!
            op = new Operation(Methods.Mult);
            op += Methods.Add;

            //apelarea delegatului se face ca si cum am apela metoda incapsulata!
            Console.WriteLine(op(3, 4));
            
            //InstanceMethods obj = new InstanceMethods()
            //{
            //    A = 10,
            //    B = 20
            //};

            //Operation1 op1 = new Operation1(obj.Add);

            //Console.WriteLine(op1());

            Console.ReadKey();
        }


Observatie: un delegat se implementeaza de fapt ca o clasa in C#.
La declararea unui delegat se genereaza o clasa derivata din clasa "MulticastDelegate".

Metode anonime

Orice delegat, pentru a putea fi utilizat, trebuie sa fie initializat (cu o referinta catre o metoda).
Daca nu dorim sa avem o clasa speciala pentru metoda respectiva, se poate utiliza ad-hoc, la momentul respectiv,
o metoda anonima.

namespace DelegateAppNew
{
    public delegate void Log(string msg);

    class Program
    {
        static void Main(string[] args)
        {
            Log log = delegate (string m) { Console.WriteLine(m); }; //aceasta se numeste metoda anonima

            log("Hello, this is a console logger!");

            log = delegate (string m) 
            {
                File.WriteAllText("Log.txt", m);
            };
            
            log("Hello, this is a file logger!");

            Console.ReadKey();
        }
    }
}

Expresii lambda

C#, pentru a simplica lucrul cu tipuul delegate, a definit niste delegati de forma urmatoare:

Action, Action<T>, Action<T1,T2>,... (pana la 16 param.)

Func<T>, Func<T,R>, Func<T1,T2,R>,....

Delegatii de tip Action incapsuleaza metode (cu zero sau mai multi param care returneaza void)
Delegatii de tip Func incapsuleaza metode (cu zero sau mai multi param care returneaza o anumita valoare)

class Program
    {
        static void Main(string[] args)
        {
            Action<string> log = m => Console.WriteLine(m); //aceasta se numeste expresie lambda (functie lambda)

            log("Hello, this is a console logger!");

            log = m => 
            {
                File.WriteAllText("Log.txt", m);
            };
            
            log("Hello, this is a file logger!");

            Console.ReadKey();
        }
    }


   class Program
    {
        public static void Log(Action<string> log, string msg)
        {
            if (log != null)
            {
                log(msg);
            }
        }
        
        
        static void Main(string[] args)
        {
            //Action<string> log = m => Console.WriteLine(m); //aceasta se numeste expresie lambda (functie lambda)

            //log("Hello, this is a console logger!");

            Log(m => Console.WriteLine(m), "Hello, this is a console logger!");

            //log = m => 
            //{
            //    File.WriteAllText("Log.txt", m);
            //};

            //log("Hello, this is a file logger!");

            Log(m => File.WriteAllText("Log.txt", m), "Hello, this is a file logger!");

            Console.ReadKey();
        }
    }

class Program
    {
        public static void Log(Action<string> log, string msg)
        {
            if (log != null)
            {
                log(msg);
            }
        }
        
        
        static void Main(string[] args)
        {
            //Action<string> log = m => Console.WriteLine(m); //aceasta se numeste expresie lambda (functie lambda)

            //log("Hello, this is a console logger!");

            //Log(m => Console.WriteLine(m), "Hello, this is a console logger!");

            //log = m => 
            //{
            //    File.WriteAllText("Log.txt", m);
            //};

            //log("Hello, this is a file logger!");

            //Log(m => File.WriteAllText("Log.txt", m), "Hello, this is a file logger!");

            Func<string> f = () => { return "cocolino"; };

            Func<int, string> f1 = (x) => "hello, " + x;

            Console.WriteLine(f());
            Console.WriteLine(f1(25));

            Console.ReadKey();
        }
    }

Metode extinse

Pe scurt, o metoda extinsa permite extinderea tipurilor deja existente cu noi metode, fara modificara codului sursa al acestora.
Sunt declarate doar in clase statice, cu referinta this.

De exemplu, ca sa extindem clasa string cu o noua metoda m, procedam astfel:

public static Extension
{
	public static void m(this string s)
	{
		
	}
}




