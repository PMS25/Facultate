Interfete in C# 

Tipul 'interface' este mecanismul prin care
putem factoriza toate metodele publice comune mai multor clase
pe care dorim sa le expunem clientilor

O interfata evidentiaza un fel de "contract" intre implementari concrete
(clase concrete) si utilizatorii acestora.

Utilizarea interfelor are ca efect scrierea aplicatiilor cu un caracter
general, usor de extins (extensibile) si usor de testat (testabile)

De ce? deoarece clasele client (o clasa client este o clasa care utilizeaza
metode ale altei clase ce implementeaza interfata!) nu depind in mod direct
de clasele concrete. Ci sunt dependente doar de interfata!!

cum se declara o interfata in C#

public interface NumeInferfata
{
	//declarari de metode (fara implementare)
	void InterfaceMethod();
}

Scenariu:

Sa se implementeze posibilitatea inregistrarii activitatilor si/sau erorilor
care apar in cadrul unei aplicatii. (mecanism care poarta numele de "logging")

Un posibil model de "log" ar putea fi urmatorul:

namespace Logger
{
    public class LogModel
    {
        public string Message { get; set; }
        public LogType Type { get; set; }
        public DateTime Date { get; set; }
        public string ApplicationName { get; set; }
    }
}

   public enum LogType
    {
        Info = 1,
        Warn = 2,
        Debug = 3,
        Error = 4
    }

Deorece dorim ca libraria noastra Logger sa fie extensibila (sa putem utiliza 
diverse medii de storace a logurilor: consola, fisier, baza de date...), 
vom crea o interfata comuna ILogger cu o metoda Log care efectueaza operatia
de logging.

Aceasta interfata va trebui sa fie implementata de clasele concrete:

ConsoleLogger, FileLogger, DatabaseLogger

 public interface ILogger
    {
        void Log(List<LogModel> logs); //metoda comuna claselor "logger"
    }

/////////////////////////////////////////////////////////////

namespace Logger
{
    public class ConsoleLogger : ILogger
    {
        //metoda din interfata
        public void Log(List<LogModel> logs)
        {
            if (logs != null)
            {
                foreach(var log in logs)
                {
                    log.ApplicationName = ConfigurationManager.AppSettings["ApplicationName"];
                    log.Date = DateTime.Now;
                    Console.WriteLine(log);
                }
            }
        }
    }
}
 
////////////////////////////////////////////////////////////////////

namespace Logger
{
    public class FileLogger : ILogger
    {
        public void Log(List<LogModel> logs)
        {
            if (logs != null)
            {
                var fileName = ConfigurationManager.AppSettings["LogFile"];

                foreach (var log in logs)
                {
                    log.ApplicationName = ConfigurationManager.AppSettings["ApplicationName"];
                    log.Date = DateTime.Now;
                    File.AppendAllText(fileName, $"{log}\n");
                }
            }
        }
  
///////////////////////////////////////////////////////////////////////


    class Program
    {
        static void Main(string[] args)
        {
            ILogger logger = new ConsoleLogger();

            logger.Log(new List<LogModel>()
            {
                new LogModel()
                {
                    Message = "action1",
                    Type = LogType.Info
                },

                new LogModel()
                {
                    Message = "action2",
                    Type = LogType.Error
                }
            });


            Console.ReadKey();
        }

////////////////////////app.config////////////////////////////
<?xml version="1.0" encoding="utf-8" ?>
<configuration>
    <startup> 
        <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.6.1" />
    </startup>
  <appSettings>
    <add key="LogFile" value="Log.txt" />
    <add key="ApplicationName" value="LogApplication" />
  </appSettings>
</configuration>


